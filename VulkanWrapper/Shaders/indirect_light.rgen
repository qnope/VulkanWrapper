#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1) uniform sampler2D g_position;
layout(set = 0, binding = 2) uniform sampler2D g_normal;
layout(set = 0, binding = 3, rgba32f) coherent uniform image2D output_image;
layout(set = 0, binding = 4) uniform sampler2D g_albedo;
layout(set = 0, binding = 5) uniform sampler2D g_ao;
layout(set = 0, binding = 6) uniform sampler2D g_tangent;
layout(set = 0, binding = 7) uniform sampler2D g_bitangent;

// Random sampling with Cranley-Patterson rotation
#define RANDOM_XI_BUFFER_BINDING 8
#define RANDOM_NOISE_TEXTURE_BINDING 9
#include "random.glsl"

#include "atmosphere_params.glsl"

layout(push_constant) uniform PushConstants {
    SkyParameters sky;
    uint frame_count;
    uint width;
    uint height;
};

#include "atmosphere_scattering.glsl"

layout(location = 0) rayPayloadEXT vec3 payload;

// Compute ambient contribution using the same formula as sun_light.frag
// ambient = (albedo / PI) * L_sun * solid_angle * 0.05 * ao
vec3 compute_ambient(SkyParameters p, vec3 albedo, float ao) {
    // Direction TO the sun
    vec3 L = normalize(-atmo_star_direction(p));

    // Compute atmospheric transmittance
    vec3 atmo_trans = atmo_transmittance_to_space(p, atmo_observer_origin(p), L);

    // Compute sun radiance at ground level (W/m^2/sr)
    vec3 L_sun = atmo_sun_radiance(p) * atmo_trans * atmo_star_color(p);

    // Convert to luminance units (cd/m^2/sr)
    L_sun *= atmo_luminous_efficiency(p);

    // Ambient contribution: 5% of sun irradiance modulated by AO
    float solid_angle = atmo_star_solid_angle(p);
    return (albedo / ATMO_PI) * L_sun * solid_angle * 0.05 * ao;
}

void main() {
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    vec2 uv = (vec2(pixel) + 0.5) / vec2(width, height);

    // Sample G-buffer
    vec3 position = texture(g_position, uv).rgb;
    vec3 normal = normalize(texture(g_normal, uv).rgb);
    vec3 tangent = normalize(texture(g_tangent, uv).rgb);
    vec3 bitangent = normalize(texture(g_bitangent, uv).rgb);
    vec3 albedo = texture(g_albedo, uv).rgb;
    float ao = texture(g_ao, uv).r;

    // Skip pixels with invalid normals (e.g., sky pixels)
    if (length(normal) < 0.5) {
        // For invalid pixels, write zero on first frame, keep existing otherwise
        if (frame_count == 0) {
            imageStore(output_image, pixel, vec4(0.0, 0.0, 0.0, 1.0));
        }
        return;
    }

    // Get random sample using Cranley-Patterson rotation for per-pixel decorrelation
    vec2 xi = get_sample(frame_count, pixel);

    // Generate cosine-weighted direction in hemisphere around normal
    // Use TBN from G-buffer for consistent tangent space
    vec3 ray_dir = sample_hemisphere_cosine(normal, tangent, bitangent, xi);

    // Trace ray in all hemisphere directions (both upward and downward).
    // Upward rays may hit sky (miss shader returns sky radiance * albedo)
    // or geometry (closest hit shader returns sun bounce * albedo).
    // Downward rays that hit geometry contribute bounced sun light.
    float bias = max(0.1, length(position) * 0.0005);
    vec3 ray_origin = position + normal * bias;
    float t_min = 0.0;
    float t_max = 100000.0;

    uint flags = gl_RayFlagsOpaqueEXT;

    // Pass albedo via payload for multiplication in hit/miss shaders.
    // For Lambertian BRDF (f = albedo/PI) with cosine-weighted sampling:
    // L_out = (1/N) * sum (albedo/PI) * L(wi) * cos(theta_i) / PDF(wi)
    // With PDF = cos(theta) / PI, this simplifies to:
    // L_out = (1/N) * sum albedo * L(wi)
    // The PI factors cancel out completely.
    payload = albedo;

    traceRayEXT(
        tlas,
        flags,
        0xFF,
        0,  // sbtRecordOffset - hit group
        0,  // sbtRecordStride
        0,  // missIndex
        ray_origin,
        t_min,
        ray_dir,
        t_max,
        0   // payload location
    );

    // payload now contains either:
    // - albedo * bounce_radiance if we hit geometry (from closest hit shader)
    // - albedo * sky_radiance if we missed (from miss shader)
    vec3 incoming_radiance = payload;

    // Sanitize NaN/Inf from ray tracing results. This can occur when
    // the miss shader computes sky radiance for rays that escape geometry
    // and travel near the planet surface, where the atmosphere
    // integration encounters numerical edge cases.
    if (any(isnan(incoming_radiance)) || any(isinf(incoming_radiance))) {
        incoming_radiance = vec3(0.0);
    }

    // Add ambient contribution with AO (same formula as sun_light.frag)
    vec3 ambient = vec3(0.0); //compute_ambient(sky, albedo, ao);

    // Total indirect lighting = ray-traced sky + ambient with AO
    vec3 total_indirect = incoming_radiance + ambient;

    // Read existing accumulated value
    vec4 accumulated = imageLoad(output_image, pixel);

    // Progressive accumulation with running average
    // blend_factor = 1/(frameCount+1) gives equal weight to all samples
    vec3 new_color;
    if (frame_count == 0) {
        // First frame: just use the new sample
        new_color = total_indirect;
    } else {
        // Subsequent frames: blend with accumulated result
        float blend_factor = 1.0 / float(frame_count + 1);
        new_color = mix(accumulated.rgb, total_indirect, blend_factor);
    }

    imageStore(output_image, pixel, vec4(new_color, 1.0));
}
